diff --git a/Project1/pingpong.c b/Project1/pingpong.c
new file mode 100644
index 0000000..e345183
--- /dev/null
+++ b/Project1/pingpong.c
@@ -0,0 +1,74 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int p2c[2]; // Pipe for parent to child
+  int c2p[2]; // Pipe for child to parent
+
+  if (pipe(p2c) < 0 || pipe(c2p) < 0) {
+    fprintf(2, "pingpong: pipe creation failed\n");
+    exit(1);
+  }
+
+  char buf[1];
+
+  int pid = fork();
+
+  if (pid < 0) {
+    fprintf(2, "pingpong: fork failed\n");
+    exit(1);
+  }
+
+  if (pid == 0) {
+    // --- CHILD PROCESS ---
+
+    close(p2c[1]); 
+    close(c2p[0]); 
+
+    if (read(p2c[0], buf, 1) != 1) {
+      fprintf(2, "pingpong: child failed to read from parent\n");
+      exit(1);
+    }
+    
+    printf("%d: received ping\n", getpid());
+
+    if (write(c2p[1], buf, 1) != 1) {
+      fprintf(2, "pingpong: child failed to write to parent\n");
+      exit(1);
+    }
+
+    close(p2c[0]);
+    close(c2p[1]);
+    
+    exit(0);
+
+  } else {
+    // --- PARENT PROCESS ---
+
+    close(p2c[0]); 
+    close(c2p[1]); 
+
+    buf[0] = 'B'; // Any byte will do.
+    if (write(p2c[1], buf, 1) != 1) {
+      fprintf(2, "pingpong: parent failed to write to child\n");
+      exit(1);
+    }
+
+    if (read(c2p[0], buf, 1) != 1) {
+      fprintf(2, "pingpong: parent failed to read from child\n");
+      exit(1);
+    }
+
+    printf("%d: received pong\n", getpid());
+
+    close(p2c[1]);
+    close(c2p[0]);
+
+    wait(0);
+    
+    exit(0);
+  }
+}
diff --git a/Project1/primes.c b/Project1/primes.c
new file mode 100644
index 0000000..39d48b9
--- /dev/null
+++ b/Project1/primes.c
@@ -0,0 +1,72 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+void sieve(int left_fd) __attribute__((noreturn));
+
+void sieve(int left_fd) {
+  int prime;
+  int n;
+  int p[2]; 
+
+  if (read(left_fd, &prime, sizeof(prime)) == 0) {
+    close(left_fd);
+    exit(0);
+  }
+
+  printf("prime %d\n", prime);
+
+  pipe(p);
+
+  if (fork() == 0) {
+    // --- Child Process ---
+    
+    close(p[1]);
+    close(left_fd);
+    sieve(p[0]);
+
+  } 
+  else {
+    // --- Parent Process ---
+
+    close(p[0]);
+
+    while (read(left_fd, &n, sizeof(n)) > 0) {
+      if (n % prime != 0) {
+        write(p[1], &n, sizeof(n));
+      }
+    }
+
+    close(left_fd);
+    close(p[1]); 
+    wait(0);
+  }
+
+  exit(0);
+}
+
+int main(int argc, char *argv[]) {
+  int p[2];
+
+  pipe(p);
+
+  if (fork() == 0) {
+    close(p[1]);
+    sieve(p[0]);
+  } 
+  else {
+    close(p[0]);
+    for (int i = 2; i <= 280; i++) {
+      if (write(p[1], &i, sizeof(i)) != sizeof(i)) {
+        fprintf(2, "write error\n");
+        exit(1);
+      }
+    }
+    close(p[1]);
+    wait(0);
+  }
+
+  exit(0);
+}
+
+
diff --git a/Project1/sleep.c b/Project1/sleep.c
new file mode 100644
index 0000000..1903121
--- /dev/null
+++ b/Project1/sleep.c
@@ -0,0 +1,14 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int 
+main(int argc, char *argv[])
+{
+    if(argc != 2){
+        fprintf(2, "sleep: usage: sleep <nsec>\n");
+        exit(1);
+    }
+    sleep(atoi(argv[1]));
+    exit(0);
+}
