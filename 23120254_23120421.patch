diff --git a/Project1/pingpong.c b/Project1/pingpong.c
new file mode 100644
index 0000000..e345183
--- /dev/null
+++ b/Project1/pingpong.c
@@ -0,0 +1,74 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int
+main(int argc, char *argv[])
+{
+  int p2c[2]; // Pipe for parent to child
+  int c2p[2]; // Pipe for child to parent
+
+  if (pipe(p2c) < 0 || pipe(c2p) < 0) {
+    fprintf(2, "pingpong: pipe creation failed\n");
+    exit(1);
+  }
+
+  char buf[1];
+
+  int pid = fork();
+
+  if (pid < 0) {
+    fprintf(2, "pingpong: fork failed\n");
+    exit(1);
+  }
+
+  if (pid == 0) {
+    // --- CHILD PROCESS ---
+
+    close(p2c[1]); 
+    close(c2p[0]); 
+
+    if (read(p2c[0], buf, 1) != 1) {
+      fprintf(2, "pingpong: child failed to read from parent\n");
+      exit(1);
+    }
+    
+    printf("%d: received ping\n", getpid());
+
+    if (write(c2p[1], buf, 1) != 1) {
+      fprintf(2, "pingpong: child failed to write to parent\n");
+      exit(1);
+    }
+
+    close(p2c[0]);
+    close(c2p[1]);
+    
+    exit(0);
+
+  } else {
+    // --- PARENT PROCESS ---
+
+    close(p2c[0]); 
+    close(c2p[1]); 
+
+    buf[0] = 'B'; // Any byte will do.
+    if (write(p2c[1], buf, 1) != 1) {
+      fprintf(2, "pingpong: parent failed to write to child\n");
+      exit(1);
+    }
+
+    if (read(c2p[0], buf, 1) != 1) {
+      fprintf(2, "pingpong: parent failed to read from child\n");
+      exit(1);
+    }
+
+    printf("%d: received pong\n", getpid());
+
+    close(p2c[1]);
+    close(c2p[0]);
+
+    wait(0);
+    
+    exit(0);
+  }
+}
diff --git a/Project1/primes.c b/Project1/primes.c
new file mode 100644
index 0000000..39d48b9
--- /dev/null
+++ b/Project1/primes.c
@@ -0,0 +1,72 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+void sieve(int left_fd) __attribute__((noreturn));
+
+void sieve(int left_fd) {
+  int prime;
+  int n;
+  int p[2]; 
+
+  if (read(left_fd, &prime, sizeof(prime)) == 0) {
+    close(left_fd);
+    exit(0);
+  }
+
+  printf("prime %d\n", prime);
+
+  pipe(p);
+
+  if (fork() == 0) {
+    // --- Child Process ---
+    
+    close(p[1]);
+    close(left_fd);
+    sieve(p[0]);
+
+  } 
+  else {
+    // --- Parent Process ---
+
+    close(p[0]);
+
+    while (read(left_fd, &n, sizeof(n)) > 0) {
+      if (n % prime != 0) {
+        write(p[1], &n, sizeof(n));
+      }
+    }
+
+    close(left_fd);
+    close(p[1]); 
+    wait(0);
+  }
+
+  exit(0);
+}
+
+int main(int argc, char *argv[]) {
+  int p[2];
+
+  pipe(p);
+
+  if (fork() == 0) {
+    close(p[1]);
+    sieve(p[0]);
+  } 
+  else {
+    close(p[0]);
+    for (int i = 2; i <= 280; i++) {
+      if (write(p[1], &i, sizeof(i)) != sizeof(i)) {
+        fprintf(2, "write error\n");
+        exit(1);
+      }
+    }
+    close(p[1]);
+    wait(0);
+  }
+
+  exit(0);
+}
+
+
diff --git a/Project1/sleep.c b/Project1/sleep.c
new file mode 100644
index 0000000..1903121
--- /dev/null
+++ b/Project1/sleep.c
@@ -0,0 +1,14 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int 
+main(int argc, char *argv[])
+{
+    if(argc != 2){
+        fprintf(2, "sleep: usage: sleep <nsec>\n");
+        exit(1);
+    }
+    sleep(atoi(argv[1]));
+    exit(0);
+}
diff --git a/Project1/find.c b/Project1/find.c
new file mode 100644
index 0000000..1903122
--- /dev/null
+++ b/Project1/find.c
@@ -0,0 +1,83 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+
+char*
+fmtname(char *path)
+{
+	char *p;
+
+	// Find first character after last slash.
+	for(p=path+strlen(path); p >= path && *p != '/'; p--)
+		;
+	p++;
+
+	return p;
+}
+
+void
+find(char *path, char *targetname) 
+{
+	char buf[512], *p;
+	int fd;
+	struct dirent de;
+	struct stat st;
+
+	if (!strcmp(fmtname(path), targetname)) {
+		printf("%s\n", path);
+	}
+
+	if ((fd = open(path, O_RDONLY)) < 0) {
+		fprintf(2, "find: cannot open [%s], fd=%d\n", path, fd);
+		return;
+	}
+
+	if (fstat(fd, &st) < 0) {
+		fprintf(2, "find: cannot stat %s\n", path);
+		close(fd);
+		return;
+	}
+
+	if (st.type != T_DIR) {
+		close(fd);
+		return;
+	}
+
+	// st.type == T_DIR
+	
+	if (strlen(path) + 1 + DIRSIZ + 1 > sizeof buf) {
+		printf("find: path too long\n");
+		close(fd);
+		return;
+	}
+	strcpy(buf, path);
+	p = buf+strlen(buf);
+	*p++ = '/';
+	while (read(fd, &de, sizeof(de)) == sizeof(de)) {
+		if (de.inum == 0)
+			continue;
+		memmove(p, de.name, DIRSIZ);
+		p[DIRSIZ] = 0;
+		
+		if (!strcmp(de.name, ".") || !strcmp(de.name, ".."))
+			continue;
+
+		find(buf, targetname);
+	}
+	close(fd);
+}
+
+int
+main(int argc, char *argv[])
+{
+	if(argc < 3){
+		fprintf(2, "usage: find path filename\n");
+		exit(1);
+	}
+
+	find(argv[1], argv[2]);
+
+	exit(0);
+}
diff --git a/Project1/xargs.c b/Project1/xargs.c
new file mode 100644
index 0000000..1903123
--- /dev/null
+++ b/Project1/xargs.c
@@ -0,0 +1,46 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/param.h"
+
+int
+main(int argc, char *argv[])
+{
+    if (argc < 2) {
+        fprintf(2, "Usage: xargs command [args...]\n");
+        exit(1);
+    }
+
+    char buf[512];
+    char *args[MAXARG];
+    int n = 0;
+
+    // Copy command + its fixed arguments (e.g. "echo bye")
+    for (int i = 1; i < argc; i++) {
+        args[n++] = argv[i];
+    }
+
+    int m = 0;
+    while (read(0, &buf[m], 1) == 1) {
+        if (buf[m] == '\n') {
+            buf[m] = 0; // Replace newline with null terminator
+
+            // Append this line as one argument
+            args[n] = buf;
+            args[n + 1] = 0;
+
+            if (fork() == 0) {
+                exec(args[0], args);
+                fprintf(2, "xargs: exec failed\n");
+                exit(1);
+            }
+            wait(0);
+
+            m = 0; // reset for next line
+        } else {
+            m++;
+        }
+    }
+
+    exit(0);
+}